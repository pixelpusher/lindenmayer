function t(t){var s,i=t[0].match(/(.+)<(.)/),o=t[0].match(/(.)>(.+)/);if(null===i&&null===o)return t;var r=t[1].successor||t[1].successors?t[1]:{successor:t[1]};return null!==i&&(s=i[2],r.leftCtx=i[1]),null!==o&&(s=o[1],r.rightCtx=o[2]),[s,r]}function s(t){if("string"!=typeof t&&t instanceof String==!1)return t;var s=[];for(var i of t)s.push({symbol:i});return s}function i(t,i){return t[1]=function t(i,o){if(i.hasOwnProperty("successors"))for(var r=0;r<i.successors.length;r++)i.successors[r]=t(i.successors[r],o);else!1===i.hasOwnProperty("successor")&&(i={successor:i});return o&&i.hasOwnProperty("successor")&&(i.successor=s(i.successor)),i}(t[1],i),t}class LSystem{constructor(t){var{axiom:s="",productions:i,finals:o,branchSymbols:r="[]",ignoredSymbols:e="+-&^/|\\",allowClassicSyntax:n=!0,classicParametricSyntax:a=!1,forceObjects:c=!1,debug:h=!1}=t;this.ignoredSymbols=e,this.debug=h,this.branchSymbols=r,this.allowClassicSyntax=n,this.classicParametricSyntax=a,this.forceObjects=c,this.setAxiom(s),this.clearProductions(),i&&this.setProductions(i),o&&this.setFinals(o)}setAxiom(t){this.axiom=this.forceObjects?s(t):t}getRaw(){return this.axiom}getString(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return"string"==typeof this.axiom?this.axiom:!0===t?this.axiom.reduce((t,s)=>{if(void 0===s.symbol)throw console.log("found:",s),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+s.symbol},""):JSON.stringify(this.axiom)}setProduction(s,o){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=[s,o];if(void 0===e)throw new Error("no production specified.");if(o.successor&&o.successors)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.allowClassicSyntax&&(e=t(e)),(e=i(e,this.forceObjects))[1].isStochastic=void 0!==e[1].successors&&e[1].successors.every(t=>void 0!==t.weight),e[1].isStochastic)for(var n of(e[1].weightSum=0,e[1].successors))e[1].weightSum+=n.weight;var a=e[0];if(!0===r&&this.productions.has(a)){var c=this.productions.get(a),h=c.successor,l=c.successors;h&&!l&&(c={successors:[c]}),c.successors.push(e[1]),this.productions.set(a,c)}else this.productions.set(a,e[1])}setProductions(t){if(void 0===t)throw new Error("no production specified.");for(var[s,i]of(this.clearProductions(),Object.entries(t)))this.setProduction(s,i,!0)}clearProductions(){this.productions=new Map}setFinal(t,s){var i=[t,s];if(void 0===i)throw new Error("no final specified.");this.finals.set(i[0],i[1])}setFinals(t){if(void 0===t)throw new Error("no finals specified.");for(var s in this.finals=new Map,t)t.hasOwnProperty(s)&&this.setFinal(s,t[s])}getProductionResult(t,s,i,o){var r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],e=void 0!==t.leftCtx||void 0!==t.rightCtx,n=!1,a=!0;if(void 0!==t.condition&&!1===t.condition({index:s,currentAxiom:this.axiom,part:i,params:o})?a=!1:e&&(void 0!==t.leftCtx&&void 0!==t.rightCtx?a=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result&&this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.leftCtx?a=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.rightCtx&&(a=this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result)),!1===a)n=!1;else if(t.successors){var c,h;for(var l of(t.isStochastic&&(h=Math.random()*t.weightSum,c=0),t.successors))if(!(t.isStochastic&&(c+=l.weight)<h)){var u=this.getProductionResult(l,s,i,o,!0);if(void 0!==u&&!1!==u){n=u;break}}}else n="function"==typeof t.successor?t.successor({index:s,currentAxiom:this.axiom,part:i,params:o}):t.successor;return n||(r?n:i)}applyProductions(){var t="string"==typeof this.axiom?"":[],s=0;for(var i of this.axiom){var o=i.symbol||i,r=i.params||[],e=i;if(this.productions.has(o)){var n=this.productions.get(o);e=this.getProductionResult(n,s,i,r)}"string"==typeof t?t+=e:e instanceof Array?t.push(...e):t.push(e),s++}return this.axiom=t,t}iterate(){var t,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.iterations=s;for(var i=0;i<s;i++)t=this.applyProductions();return t}final(t){var s=0;for(var i of this.axiom){var o=i;if("object"==typeof i&&i.symbol&&(o=i.symbol),this.finals.has(o)){var r=this.finals.get(o),e=typeof r;if("function"!==e)throw Error("'"+o+"' has an object for a final function. But it is __not a function__ but a "+e+"!");r({index:s,part:i},t)}s++}}getFuncs(){var t=[],s=0;for(var i of this.axiom){var o=i;if("object"==typeof i&&i.symbol&&(o=i.symbol),this.finals.has(o)){var r=this.finals.get(o),e=typeof r;if("function"!==e)throw Error("'"+o+"' has an object for a final function. But it is __not a function__ but a "+e+"!");t.push([r,s,i]),s++}}return t}*run(t){var s=this.getFuncs(t),i=s.length-1;yield*function*(){for(var o of s){var r=o[0],e=o[1];r({index:e,part:o[2]},t),yield{index:e,total:i}}}()}*steps(){var t=this,s=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1?arguments[1]:void 0,o=function*(){var s=0,o=function*(o){var r,e=o;if("object"==typeof o&&o.symbol&&(e=o.symbol),t.finals.has(e)){var n=t.finals.get(e),a=typeof n;if("function"!==a)throw Error("'"+e+"' has an object for a final function. But it is __not a function__ but a "+a+"!");yield(r=n({index:s,part:o},i),void 0===r&&(r={part:o,index:s}),r)}s++};for(var r of t.axiom)yield*o(r);yield{part:!1,index:-1}};do{yield*o()}while(s)}match(t){var{axiom_:s,match:i,ignoredSymbols:o,branchSymbols:r,index:e,direction:n}=t,a=0,c=0;s=s||this.axiom,void 0===r&&(r=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===o&&(o=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);var h,l,u,f,d,m,y,g=[];if("right"===n)f=m=1,u=e+1,d=0,y=i.length,r.length>0&&([h,l]=r);else{if("left"!==n)throw Error(n,"is not a valid direction for matching.");f=m=-1,u=e-1,d=i.length-1,y=-1,r.length>0&&([l,h]=r)}for(;u<s.length&&u>=0;u+=f){var b=s[u].symbol||s[u],v=i[d];if(b===v){if((0===a||c>0)&&(b===h?(c++,a++,d+=m):b===l?(c=Math.max(0,c-1),a=Math.max(0,a-1),0===c&&(d+=m)):(g.push(u),d+=m)),d===y)return{result:!0,matchIndices:g}}else if(b===h)a++,c>0&&c++;else if(b===l)a=Math.max(0,a-1),c>0&&(c=Math.max(0,c-1));else if((0===a||c>0&&v!==l)&&!1===o.includes(b))return{result:!1,matchIndices:g}}return{result:!1,matchIndices:g}}}LSystem.getStringResult=LSystem.getString,LSystem.transformClassicStochasticProductions=function(t){return function(){for(var s=t,i=s.length,o=Math.random(),r=0;r<i;r++)if(o<=(r+1)/i)return s[r];console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}},LSystem.transformClassicCSProduction=t,LSystem.transformClassicParametricAxiom=function(t){for(var s=t.replace(/\s+/g,"").split(/[\(\)]/),i=[],o=0;o<s.length-1;o+=2){var r=s[o+1].split(",").map(Number);i.push({symbol:s[o],params:r})}},LSystem.testClassicParametricSyntax=function(t){return/\(.+\)/.test(t)};export default LSystem;
